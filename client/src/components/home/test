import { useChatStore } from '@/store/useChatStore'
import { useEffect, useRef, useState } from 'react'
import ChatHeader from './chat-header'
import MessageInput from './message-input'
import { useAuthStore } from '@/store/useAuthStore'
import { MessageType } from '@/types/enum/MessageType'

const ChatContainer = () => {
  const {
    selectedChat,
    selectedChatMessages,
    getSelectedChatMessages,
    isSelectedChatMessagesLoading,
    markChatAsRead,
  } = useChatStore()

  const { authUser } = useAuthStore()

  const bottomRef = useRef<HTMLDivElement | null>(null)
  const [hoveredMessageId, setHoveredMessageId] = useState<string | null>(null)

  useEffect(() => {
    bottomRef.current?.scrollIntoView({ behavior: 'smooth' })
  }, [selectedChatMessages.length])

  useEffect(() => {
    if (selectedChat) {
      getSelectedChatMessages(selectedChat.id)
    }
  }, [selectedChat, getSelectedChatMessages])

  useEffect(() => {
    if (!selectedChat || !selectedChatMessages.length || !authUser?.id) return

    const lastMessage = selectedChatMessages[selectedChatMessages.length - 1]
    console.log('Last message:', lastMessage)

    // Only mark as seen if it's NOT my own message
    if (lastMessage.senderId !== authUser.id) {
      markChatAsRead(selectedChat.id)
    }
  }, [selectedChatMessages])

  // Get the latest seen message for each user (Messenger-style)
  const getLatestSeenByUser = () => {
    const latestSeenByUser = new Map<string, { messageId: string; readAt: string }>()

    // Go through messages in reverse order to find the latest seen message for each user
    for (let i = selectedChatMessages.length - 1; i >= 0; i--) {
      const message = selectedChatMessages[i]

      if (message.readInfo) {
        message.readInfo.forEach((readInfo) => {
          // Skip if it's the current user's read info
          if (readInfo.userId === authUser?.id) return

          // Only set if we haven't seen this user yet (since we're going backwards)
          if (!latestSeenByUser.has(readInfo.userId)) {
            latestSeenByUser.set(readInfo.userId, {
              messageId: message.id,
              readAt: readInfo.readAt,
            })
          }
        })
      }
    }

    return latestSeenByUser
  }

  const latestSeenByUser = getLatestSeenByUser()

  // Check if a message should show seen indicators
  const shouldShowSeenIndicators = (messageId: string) => {
    const seenUsers = Array.from(latestSeenByUser.entries())
      .filter(([_, data]) => data.messageId === messageId)
      .map(([userId]) => userId)

    return seenUsers
  }

  if (isSelectedChatMessagesLoading) {
    return (
      <div className="flex-1 flex items-center justify-center">
        <span className="loading loading-spinner loading-lg"></span>
      </div>
    )
  }

  return (
    <div className="flex-1 flex flex-col h-full">
      <ChatHeader />

      <div className="flex-1 overflow-y-auto p-4 space-y-1">
        {selectedChatMessages.map((message, index) => {
          // SYSTEM message
          if (message.messageType === MessageType.SYSTEM) {
            return (
              <div key={message.id} className="w-full text-center py-2">
                <span className="text-xs text-base-content/60 italic">{message.content}</span>
              </div>
            )
          }

          const isMyMessage = message.senderId === authUser?.id
          const seenByUsers = shouldShowSeenIndicators(message.id)
          const isLastMessage = index === selectedChatMessages.length - 1

          // Find the sender's info from chat participants
          const senderInfo = selectedChat?.participantsInfo?.find((p) => p.id === message.senderId)

          // Check if this message is consecutive from the same sender
          const prevMessage = selectedChatMessages[index - 1]
          const isConsecutive =
            prevMessage &&
            prevMessage.senderId === message.senderId &&
            prevMessage.messageType !== MessageType.SYSTEM

          // Check if next message is from same sender
          const nextMessage = selectedChatMessages[index + 1]
          const nextIsFromSameSender =
            nextMessage &&
            nextMessage.senderId === message.senderId &&
            nextMessage.messageType !== MessageType.SYSTEM

          return (
            <div key={message.id} className="relative">
              <div
                className={`chat ${isMyMessage ? 'chat-end' : 'chat-start'} ${
                  isConsecutive ? 'mt-1' : 'mt-4'
                }`}
                onMouseEnter={() => setHoveredMessageId(message.id)}
                onMouseLeave={() => setHoveredMessageId(null)}
              >
                {/* Display sender's name only for first message in sequence and in group chats */}
                {!isConsecutive && !isMyMessage && selectedChat?.isGroupChat && (
                  <div className="chat-header mb-1 text-xs font-semibold text-base-content/70 ml-12">
                    {senderInfo?.fullName || 'Unknown'}
                  </div>
                )}

                {/* Sender's profile image - only show for last message in sequence or standalone */}
                <div className={`chat-image avatar ${nextIsFromSameSender ? 'invisible' : ''}`}>
                  <div className="w-8 h-8 rounded-full">
                    <img
                      src={senderInfo?.profileImageUrl || '/placeholder.svg?height=32&width=32'}
                      alt="Profile"
                      className="w-full h-full object-cover rounded-full"
                    />
                  </div>
                </div>

                {/* Message bubble */}
                <div className="chat-bubble max-w-[70%] break-words whitespace-pre-wrap relative">
                  {/* Media attachment if any */}
                  {message.mediaUrl && (
                    <div className="mb-2">
                      <img
                        src={message.mediaUrl || '/placeholder.svg'}
                        alt="Attachment"
                        className="max-w-[250px] rounded-lg"
                      />
                    </div>
                  )}
                  {/* Message content */}
                  {message.content && <div>{message.content}</div>}

                  {/* Timestamp on hover */}
                  {hoveredMessageId === message.id && (
                    <div
                      className={`absolute top-0 ${
                        isMyMessage ? 'right-full mr-2' : 'left-full ml-2'
                      } 
                      bg-base-300 text-base-content text-xs px-2 py-1 rounded whitespace-nowrap z-10 shadow-lg`}
                    >
                      {new Date(message.createdAt).toLocaleString([], {
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                      })}
                    </div>
                  )}
                </div>
              </div>

              {/* Seen indicators - Messenger style */}
              {seenByUsers.length > 0 && isMyMessage && (
                <div className="flex justify-end mt-1 mr-2">
                  <div className="flex -space-x-1">
                    {seenByUsers.slice(0, 3).map((userId) => {
                      const participant = selectedChat?.participantsInfo?.find(
                        (p) => p.id === userId
                      )
                      return (
                        <div
                          key={userId}
                          className="w-4 h-4 rounded-full border-2 border-base-100 overflow-hidden tooltip"
                          data-tip={`Seen by ${participant?.fullName || 'Unknown'}`}
                        >
                          <img
                            src={
                              participant?.profileImageUrl || '/placeholder.svg?height=16&width=16'
                            }
                            alt="Seen"
                            className="w-full h-full object-cover"
                          />
                        </div>
                      )
                    })}
                    {seenByUsers.length > 3 && (
                      <div className="w-4 h-4 rounded-full bg-base-300 border-2 border-base-100 flex items-center justify-center">
                        <span className="text-xs text-base-content font-bold">
                          +{seenByUsers.length - 3}
                        </span>
                      </div>
                    )}
                  </div>
                </div>
              )}
            </div>
          )
        })}
        <div ref={bottomRef} />
      </div>

      <MessageInput />
    </div>
  )
}

export default ChatContainer
